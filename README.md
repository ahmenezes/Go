# Go
First steps using Go language  

## Where to start?

* [Tutorial: Get started with Go][getting-started]

    * [Go Dev page: Download and install][download1]
    * Prerequisites
        * **A tool to edit your code.** I have chosen VSCode (free) because I had already installed it.
    

## Tutorial 1 - Hello

1 - Open a terminal and go to your root working directory

```
% cd
% cd VSCodeProjects/GoProjects

```

2 -  Create a folder for this new code

```
% mkdir hello
% cd hello
```

3 - Enable dependency tracking for your code.

```
hello % go mod init example/hello
```

4 - In your text editor, create a file hello.go in which to write your code.

    When I created the file using VSCode, the IDE  detected a new Go file and asked to install plugins.


    > Go for VS Code v0.38.0
    The official Go extension for Visual Studio Code, providing rich language support for Go projects.

    Installing 7 tools at /Users/alvaro.menezes/go/bin in module mode.
        gotests
        gomodifytags
        impl
        goplay
        dlv
        staticcheck
        gopls

5 - Paste the following code into your hello.go file and save the file.

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

6 - Run your code to see the greeting.
```go
$ go run .
Hello, World!
```


### import code from an external package

the next step of the [tutorial] [getting-started] is to include some code from the package from pkg.go.web 

Steps look very simple 

1 - Use the same hello.go you created before.

2 - Add some lines 

```go
package main

// part 1 - import fmt for basic operations
// part 2 - import a package from https://pkg.go.dev/rsc.io/quote@v1.5.2

import (
	"fmt"

	"rsc.io/quote"
)

func main() {
	// part 1 - first hello world
	fmt.Println("Hello, World!")
	// part 2 - quote import usage
	fmt.Println(quote.Go())
}
```

3 - VSCode detects the import was not downloaded yet and suggests a quick-fix.. never the less I followed the tutorial steps

```
$ go mod tidy
go: finding module for package rsc.io/quote
go: found rsc.io/quote in rsc.io/quote v1.5.2
```

4 - Run your code to see the message generated by the function you're calling.

I used also VSCode F5 and the terminal to see the result

```console
$ go run .
```


### Messing things up 

I started by seaching for **"quote"** package and the list returned the version 4.0.1 (latest).. 

if you look at the go.mod file you will find that quote package version is:
```go
require rsc.io/quote v1.5.2
```
so I changed my **hello.go** file to import  **rsc.io/quote/v4** instead 

1 - VSCode suggests a quickfix to get the package

2 - Error message is created
```console
[Error - 15:37:06] 2023/03/08 15:37:06 command error: /Users/alvaro.menezes/VSCodeProjects/GoProjects/Go/hello/go.mod:9:2: usage: require module/path v1.2.3
/Users/alvaro.menezes/VSCodeProjects/GoProjects/Go/hello/go.mod:10:2: usage: require module/path v1.2.3

 ```

 3 - **go.mod**  gets broken 

 4 - Workaround

* Deleted **go.mod** file
    
* Create a new one
    
    ```console
    go mod init example/hello
    ```
    
* Add module requirements and sums
    
    ```console
    go mod tidy
    ```
    
* Errors were cleaned
 



## Tutorial 2 - Create a module 

The original version of the tutorial can be found here [Tutorial: Create a Go module][create-module]


1 - Create a new folder in your Go project
* I used Explorer from VSCode and proceeded with the creation of the folder **greetings**


2 - Create a new file **greetings.go**
* Once again I used the Explorer

3 - Paste the following code
```go
package greetings

import "fmt"

// Hello returns a greeting for the named person.
func Hello(name string) string {
    // Return a greeting that embeds the name in a message.
    message := fmt.Sprintf("Hi, %v. Welcome!", name)
    return message
}

```

4 - Pressed F5 and as expected returned an error
```console

Build Error: go build -o /Users/alvaro.menezes/VSCodeProjects/GoProjects/Go/greetings/__debug_bin -gcflags all=-N -l .
go: cannot find main module, but found .git/config in /Users/alvaro.menezes/VSCodeProjects/GoProjects/Go
	to create a module there, run:
	cd .. && go mod init (exit status 1)
```

5 - The tutorial was clear, before pasting you need to manage the dependencies and 
> Run the go mod init command, giving it your module path -- here, use example.com/greetings. If you publish a module, this must be a path from which your module can be downloaded by Go tools. That would be your code's repository.
```console
# since I was in the hello project 
$ cd ..
$ cd greetings
$ go mod init example.com/greetings
go: creating new go.mod: module example.com/greetings

```

This time I was a good boy and the **go.mod** file was created with he following content
```go
module example.com/greetings

go 1.20
```

6 - Analysing the pasted code
>
* Declare a greetings package to collect related functions.
* Implement a Hello function to return the greeting.
* * This function takes a name parameter whose type is string. The function also returns a string. 
* * **In Go, a function whose name starts with a capital letter** can be called by a function not in the same package. This is known in Go as an exported name. For more about exported names, see Exported names in the Go tour.


* Declare a message variable to hold your greeting.
 **In Go, the := operator is a shortcut for declaring and initializing a variable in one line** (Go uses the value on the right to determine the variable's type). Taking the long way, you might have written this as:
```go
var message string
message = fmt.Sprintf("Hi, %v. Welcome!", name)
```
* Use the fmt package's Sprintf function to create a greeting message. The first argument is a format string, and Sprintf substitutes the name parameter's value for the %v format verb. Inserting the value of the name parameter completes the greeting text.
* Return the formatted greeting text to the caller.


Notes: 
* In Go, a function whose name starts with a capital letter can be called by a function not in the same package
* In Go, the := operator is a shortcut for declaring and initializing a variable in one line (Go uses the value on the right to determine the variable's type). 



## Tutorial 3 - Call your code from another module
The original version of the tutorial can be found here [Tutorial: Call your code from another module][call-module-code]


1 - This tutorial starts with a step to create a new folder **hello**. Note that is the same folder of the hello world example. I started by renaming the previous folder to  **helloWorld** before creating the folder as suggested in the tutorial.. I'm trying to behave :)

2 - Create the diretory at the same level of greetings

```console
$ cd ..
$ mkdir hello
$ cd hello
```

3 - Enable dependency tracking for the code you're about to write. 
```console
$ go mod init example.com/hello
```

4 - in the editor create a new file **hello.go**
and paste the following code

```go
package main

import (
    "fmt"

    "example.com/greetings"
)

func main() {
    // Get a greeting message and print it.
    message := greetings.Hello("Gladys")
    fmt.Println(message)
}
```

5 - Some "strange" things happen at this time..
* the import is showing an error
* the quick-fix suggested is not making sense

6 - You need to reference your **local** module instead of the **example.com**
```console
$ go mod edit -replace example.com/greetings=../greetings

$ go mod tidy
```
* note: After this two steps the file should look like this
```go
module example.com/hello

go 1.20

replace example.com/greetings => ../greetings

require example.com/greetings v0.0.0-00010101000000-000000000000
```

* this means the command found the local code in the greetings folder saying and the dependency was created

7 - Now you can test the new code
```console
$ go run .
Hi, Gladys. Welcome!
```


## Tutorial 4 - Return and handle an error

The original version can be found here [Return and handle an error][return-and-handle-an-error]

1 - In greetings/greetings.go, add the code highlighted below.

```go
package greetings

import (
    "errors"
    "fmt"
)

// Hello returns a greeting for the named person.
func Hello(name string) (string, error) {
	 // If no name was given, return an error with a message.
	 if name == "" {
        return "", errors.New("empty name")
    }
	// Return a greeting that embeds the name in a message.
	message := fmt.Sprintf("Hi, %v. Welcome!", name)
	return message, nil
}
```

2 - in the **hello.go**, handle the error now returned
```go
package main

import (
	"fmt"
	"log"

	"example.com/greetings"
)

func main() {
	// Set properties of the predefined Logger, including
	// the log entry prefix and a flag to disable printing
	// the time, source file, and line number.
	log.SetPrefix("greetings: ")
	log.SetFlags(0)

	// Request a greeting message.
	message, err := greetings.Hello("")
	// If an error was returned, print it to the console and
	// exit the program.
	if err != nil {
		log.Fatal(err)
	}

	// If no error was returned, print the returned message
	// to the console.
	fmt.Println(message)
}

```

4 - At the command line in the hello directory, run hello.go to confirm that the code works.
Now that you're passing in an empty name, you'll get an error.
```console
$ go run .
greetings: empty name
exit status 1
```

* My editor was complaining that I was requesting two variables, but greetings.Hello returns 1 value. The reason is simple, I did'nt save the greetings.go modifications and the compiler was looking at the previous version of the code. After saviing all was OK. The line code was  
```go
	// Request a greeting message.
	message, err := greetings.Hello("")
```

## Tutorial 5 - Return and handle an error

Original steps can be found here - [Return a random greeting][random-greeting]


1 - In greetings/greetings.go, change your code so it looks like the following.
```go
package greetings

import (
    "errors"
    "fmt"
    "math/rand"
    "time"
)

// Hello returns a greeting for the named person.
func Hello(name string) (string, error) {
    // If no name was given, return an error with a message.
    if name == "" {
        return name, errors.New("empty name")
    }
    // Create a message using a random format.
    message := fmt.Sprintf(randomFormat(), name)
    return message, nil
}

// init sets initial values for variables used in the function.
func init() {
    rand.Seed(time.Now().UnixNano())
}

// randomFormat returns one of a set of greeting messages. The returned
// message is selected at random.
func randomFormat() string {
    // A slice of message formats.
    formats := []string{
        "Hi, %v. Welcome!",
        "Great to see you, %v!",
        "Hail, %v! Well met!",
    }

    // Return a randomly selected message format by specifying
    // a random index for the slice of formats.
    return formats[rand.Intn(len(formats))]
}


```

Notes: 
* In randomFormat, declare a formats slice with three message formats. When declaring a slice, you omit its size in the brackets, like this: []string. This tells Go that the size of the array underlying the slice can be dynamically changed.
* Add an init function to seed the rand package with the current time. Go executes init functions automatically at program startup, after global variables have been initialized. For more about init functions, see [Effective Go][effective_go].


2 - in hello/hello.go, change your line calling greetings.Hello


```go
 // Request a greeting message.
    message, err := greetings.Hello("Gladys")

 ```   

3 - At the command line, in the hello directory, run hello.go to confirm that the code works. Run it multiple times, noticing that the greeting changes.

```console
$ go run .
Great to see you, Gladys!

$ go run .
Hi, Gladys. Welcome!

$ go run .
Hail, Gladys! Well met!
```

## Tutorial 6  - Return greetings for multiple people

You can find the original tutorial here [Return greetings for multiple people][greetings-multiple-people]


1 - In greetings/greetings.go, add to your code the following:


```go

// Hellos returns a map that associates each of the named people
// with a greeting message.
func Hellos(names []string) (map[string]string, error) {
    // A map to associate names with messages.
    messages := make(map[string]string)
    // Loop through the received slice of names, calling
    // the Hello function to get a message for each name.
    for _, name := range names {
        message, err := Hello(name)
        if err != nil {
            return nil, err
        }
        // In the map, associate the retrieved message with
        // the name.
        messages[name] = message
    }
    return messages, nil
}
```

Notes:

* Add a Hellos function whose parameter is a slice of names rather than a single name. Also, you change one of its return types from a string to a map so you can return names mapped to greeting messages.

* Have the new Hellos function call the existing Hello function. This helps reduce duplication while also leaving both functions in place.

* Create a messages map to associate each of the received names (as a key) with a generated message (as a value). In Go, you initialize a map with the following syntax: make(map[key-type]value-type). You have the Hellos function return this map to the caller. For more about maps, see Go maps in action on the Go blog.

* Loop through the names your function received, checking that each has a non-empty value, then associate a message with each. In this for loop, range returns two values: the index of the current item in the loop and a copy of the item's value. You don't need the index, so you use the Go blank identifier (an underscore) to ignore it. For more, see The blank identifier in Effective Go.


2 - In your hello/hello.go calling code, pass a slice of names, then print the contents of the names/messages map you get back.

In hello.go, change your code so it looks like the following.

```go 
package main

import (
    "fmt"
    "log"

    "example.com/greetings"
)

func main() {
    // Set properties of the predefined Logger, including
    // the log entry prefix and a flag to disable printing
    // the time, source file, and line number.
    log.SetPrefix("greetings: ")
    log.SetFlags(0)

    // A slice of names.
    names := []string{"Gladys", "Samantha", "Darrin"}

    // Request greeting messages for the names.
    messages, err := greetings.Hellos(names)
    if err != nil {
        log.Fatal(err)
    }
    // If no error was returned, print the returned map of
    // messages to the console.
    fmt.Println(messages)
}

```

3 - At the command line, change to the directory that contains hello/hello.go, then use go run to confirm that the code works.


```console
$ go run .

map[Darrin:Hi, Darrin. Welcome! Gladys:Hail, Gladys! Well met! Samantha:Great to see you, Samantha!]
```


## Tutorial 7 - Add a test

The original tutorial can be found here [Add a test
][add-a-test]

Now it's time to add a test. In this topic, you can add a test for the **Hello** function.

1 - In the greetings directory, create a file called greetings_test.go.
Ending a file's name with _test.go tells the go test command that this file contains test functions.

2 - In greetings_test.go, paste the following code and save the file.

```go
package greetings

import (
    "testing"
    "regexp"
)

// TestHelloName calls greetings.Hello with a name, checking
// for a valid return value.
func TestHelloName(t *testing.T) {
    name := "Gladys"
    want := regexp.MustCompile(`\b`+name+`\b`)
    msg, err := Hello("Gladys")
    if !want.MatchString(msg) || err != nil {
        t.Fatalf(`Hello("Gladys") = %q, %v, want match for %#q, nil`, msg, err, want)
    }
}

// TestHelloEmpty calls greetings.Hello with an empty string,
// checking for an error.
func TestHelloEmpty(t *testing.T) {
    msg, err := Hello("")
    if msg != "" || err == nil {
        t.Fatalf(`Hello("") = %q, %v, want "", error`, msg, err)
    }
}

```

Note:
In this code, you:

* Implement test functions in the same package as the code you're testing.

* Create two test functions to test the **greetings.Hello** function. Test function names have the form *TestName*, where Name says something about the specific test. Also, test functions take a pointer to the testing package's testing.T type as a parameter. You use this parameter's methods for reporting and logging from your test.

* Implement two tests:

* * TestHelloName calls the Hello function, passing a name value with which the function should be able to return a valid response message. If the call returns an error or an unexpected response message (one that doesn't include the name you passed in), you use the t parameter's Fatalf method to print a message to the console and end execution.

* * TestHelloEmpty calls the Hello function with an empty string. This test is designed to confirm that your error handling works. If the call returns a non-empty string or no error, you use the t parameter's Fatalf method to print a message to the console and end execution.

At the command line in the greetings directory, run the **go test** command to execute the test.

The **go test** command executes test functions (whose names begin with Test) in test files (whose names end with _test.go). You can add the -v flag to get verbose output that lists all of the tests and their results.

The tests should pass.
```console
$ cd ..
$ cd greetings
$ go test
PASS
ok  	example.com/greetings	0.427s

$ go test -v
=== RUN   TestHelloName
--- PASS: TestHelloName (0.00s)
=== RUN   TestHelloEmpty
--- PASS: TestHelloEmpty (0.00s)
PASS
ok  	example.com/greetings	0.134s

```

4 - Break the greetings.Hello function to view a failing test.

The TestHelloName test function checks the return value for the name you specified as a Hello function parameter. To view a failing test result, change the greetings.Hello function so that it no longer includes the name.

In greetings/greetings.go, paste the following code in place of the Hello function. Note that the highlighted lines change the value that the function returns, as if the name argument had been accidentally removed.


```go
// Hello returns a greeting for the named person.
func Hello(name string) (string, error) {
    // If no name was given, return an error with a message.
    if name == "" {
        return name, errors.New("empty name")
    }
    // Create a message using a random format.
    // message := fmt.Sprintf(randomFormat(), name)
    message := fmt.Sprint(randomFormat())
    return message, nil
}

```

5 - At the command line in the greetings directory, run go test to execute the test.

```console

$ go test -v

=== RUN   TestHelloName
    greetings_test.go:15: Hello("Gladys") = "Great to see you, %v!", <nil>, want match for `\bGladys\b`, nil
--- FAIL: TestHelloName (0.00s)
=== RUN   TestHelloEmpty
--- PASS: TestHelloEmpty (0.00s)
FAIL
exit status 1
FAIL	example.com/greetings	0.451s
```




[download1]: https://go.dev/doc/install
[getting-started]: https://go.dev/doc/tutorial/getting-started
[create-module]: https://go.dev/doc/tutorial/create-module
[call-module-code]: https://go.dev/doc/tutorial/call-module-code

[return-and-handle-an-error]: https://go.dev/doc/tutorial/handle-errors

[random-greeting]: https://go.dev/doc/tutorial/random-greeting

[effective_go]: https://go.dev/doc/effective_go.html#init

[greetings-multiple-people]: https://go.dev/doc/tutorial/greetings-multiple-people

[add-a-test]: https://go.dev/doc/tutorial/add-a-test